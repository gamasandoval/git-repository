#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
INV_DIR="$ROOT_DIR/inventory"

die() { echo "ERROR: $*" >&2; exit 1; }

usage() {
cat <<'EOF'
Usage:
  appctl <cmd> <CLIENT> <HOST|ENV> <APP> [args...] [--all] [--exec] [--component <COMP>]
  appctl info   <CLIENT> <HOST|ENV> [APP] [--all] [--exec]
  appctl status <CLIENT> <HOST|ENV> [APP] [--all] [--exec]

Commands:
  info
  status
  logs <logname> [--lines N] [--filter REGEX]
  journal [--lines N]
  url
  start
  stop
  restart

Flags:
  --component <COMP>    target a component defined under apps.<APP>.components.<COMP>
  --all                 run against all hosts in environment (when IDENT is env)
  --exec                actually SSH and run (default prints commands)

Examples:
  appctl info PRCC TEST BEP
  appctl status PRCC TEST --exec
  appctl status PRCC TEST DW --exec
  appctl restart PRCC it-s-dw-web-t DW --component DW_CONTROLLER --exec
  appctl logs PRCC it-s-dw-web-t DW --component DW_TRANSIT transit --lines 200 --exec
EOF
}

# ---- Parse leading args ----
[[ $# -ge 1 ]] || { usage; exit 1; }
CMD="$1"; shift || true

# Require at least CLIENT + HOST|ENV for info/status; for others require +APP
[[ $# -ge 2 ]] || { usage; exit 1; }
CLIENT_RAW="$1"; shift
IDENT="$1"; shift   # HOST or ENV

APP=""
if [[ "$CMD" == "info" || "$CMD" == "status" ]]; then
  # info/status allow optional APP (if next token is not an option)
  if [[ $# -ge 1 && "${1:0:2}" != "--" ]]; then
    APP="$1"; shift
  fi
else
  [[ $# -ge 1 ]] || { usage; die "Missing <APP> for command '$CMD'"; }
  APP="$1"; shift
fi

CLIENT="$(echo "$CLIENT_RAW" | tr '[:upper:]' '[:lower:]')"
INV_FILE="$INV_DIR/${CLIENT}.json"
[[ -f "$INV_FILE" ]] || die "Inventory not found: $INV_FILE"

command -v jq >/dev/null 2>&1 || die "jq is required but not found in PATH."

# ---- Parse options anywhere in remaining args ----
ALL_MODE="no"
EXEC_MODE="print"   # print | exec
OTHER_ARGS=()
COMPONENT_ARG=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --all) ALL_MODE="yes"; shift ;;
    --exec) EXEC_MODE="exec"; shift ;;
    --exec-tty) die "--exec-tty is not supported anymore. Use --exec." ;;
    --component) shift; COMPONENT_ARG="$1"; shift ;;
    --component=*) COMPONENT_ARG="${1#*=}"; shift ;;
    -h|--help|help) usage; exit 0 ;;
    *) OTHER_ARGS+=("$1"); shift ;;
  esac
done

# ---- Resolve IDENT => host(s) ----
hosts_for_env() {
  local wanted="$1"
  local wanted_lc
  wanted_lc="$(echo "$wanted" | tr '[:upper:]' '[:lower:]' | sed 's/[[:space:]]\+$//')"

  jq -r '.hosts | to_entries[] | "\(.key)\t\(.value.environment // "")"' "$INV_FILE" \
  | while IFS=$'\t' read -r host env; do
      env="$(echo "$env" | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//')"
      env_lc="$(echo "$env" | tr '[:upper:]' '[:lower:]')"
      if [[ "$env_lc" == "$wanted_lc" ]]; then
        echo "$host"
      fi
    done
}

IDENT_IS_HOST="no"
TARGET_HOSTS=()

IDENT_LC="$(echo "$IDENT" | tr '[:upper:]' '[:lower:]')"
if jq -e ".hosts[\"$IDENT\"]" "$INV_FILE" >/dev/null 2>&1; then
  IDENT_IS_HOST="yes"
  TARGET_HOSTS=("$IDENT")
elif jq -e ".hosts[\"$IDENT_LC\"]" "$INV_FILE" >/dev/null 2>&1; then
  IDENT_IS_HOST="yes"
  TARGET_HOSTS=("$IDENT_LC")
else
  mapfile -t env_hosts < <(hosts_for_env "$IDENT")
  [[ ${#env_hosts[@]} -gt 0 ]] || die "Neither host '$IDENT' exists nor environment '$IDENT' matches any host in this inventory."
  TARGET_HOSTS=("${env_hosts[@]}")
fi

# ---- Filter hosts_for_env by APP when IDENT was an environment and APP provided ----
if [[ -n "$APP" && "$IDENT_IS_HOST" != "yes" ]]; then
  mapfile -t hosts_with_app < <(
    for h in "${TARGET_HOSTS[@]}"; do
      if jq -e ".hosts[\"$h\"].apps[\"$APP\"]" "$INV_FILE" >/dev/null 2>&1; then
        echo "$h"
      fi
    done
  )
  if [[ ${#hosts_with_app[@]} -eq 0 ]]; then
    die "App '$APP' not found on any host matching environment '$IDENT'."
  fi
  TARGET_HOSTS=("${hosts_with_app[@]}")
fi

# ---- NEW BEHAVIOR: if status (with or without APP) and IDENT is env -> default to all hosts in env
if [[ "$CMD" == "status" && "$IDENT_IS_HOST" != "yes" && ${#TARGET_HOSTS[@]} -gt 1 ]]; then
  ALL_MODE="yes"
fi

# Previous blocking behavior only applies to non-status commands (so user must choose or use --all)
if [[ "$IDENT_IS_HOST" != "yes" && ${#TARGET_HOSTS[@]} -gt 1 && "$ALL_MODE" != "yes" && "$CMD" != "status" ]]; then
  echo "The identifier '$IDENT' matches multiple hosts for client '$CLIENT_RAW':"
  for h in "${TARGET_HOSTS[@]}"; do
    env_val="$(jq -r ".hosts[\"$h\"].environment // \"<missing>\"" "$INV_FILE")"
    desc="$(jq -r ".hosts[\"$h\"].description // \"<no description>\"" "$INV_FILE")"
    echo "  - $h (env: $env_val) - $desc"
  done
  echo
  echo "Run again with a specific host, e.g.:"
  if [[ -n "$APP" ]]; then
    echo "  appctl $CMD $CLIENT_RAW ${TARGET_HOSTS[0]} $APP ${OTHER_ARGS[*]}"
  else
    echo "  appctl $CMD $CLIENT_RAW ${TARGET_HOSTS[0]} ${OTHER_ARGS[*]}"
  fi
  echo
  echo "Or run against all hosts in the environment with --all, e.g.:"
  if [[ -n "$APP" ]]; then
    echo "  appctl $CMD $CLIENT_RAW $IDENT $APP ${OTHER_ARGS[*]} --all --exec"
  else
    echo "  appctl $CMD $CLIENT_RAW $IDENT ${OTHER_ARGS[*]} --all --exec"
  fi
  exit 0
fi

# ---- SSH helpers ----
SSH_OPTS=(
  -o BatchMode=yes
  -o ConnectTimeout=10
  -o StrictHostKeyChecking=accept-new
  -o ServerAliveInterval=15
  -o ServerAliveCountMax=2
  -o LogLevel=ERROR
)

run_for_host() {
  local HOST="$1"

  jq -e ".hosts[\"$HOST\"]" "$INV_FILE" >/dev/null || die "Host '$HOST' not found in inventory."

  # If APP is provided, ensure it exists.
  if [[ -n "$APP" ]]; then
    jq -e ".hosts[\"$HOST\"].apps[\"$APP\"]" "$INV_FILE" >/dev/null || die "App '$APP' not found on host '$HOST'."
  fi

  local CLIENT_NAME ENVIRONMENT
  CLIENT_NAME="$(jq -r ".client_name" "$INV_FILE")"
  ENVIRONMENT="$(jq -r ".hosts[\"$HOST\"].environment" "$INV_FILE")"

  # App-scoped values (smart detection: support tomcat.* OR service.* + components)
  local SERVICE_UNIT BASE_DIR PORT RUN_AS_USER
  local HAS_TOMCAT="no"
  local HAS_SERVICE_OBJ="no"
  local HAS_COMPONENTS="no"

  if [[ -n "$APP" ]]; then
    if jq -e ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat" "$INV_FILE" >/dev/null 2>&1; then
      HAS_TOMCAT="yes"
      SERVICE_UNIT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.service_unit // empty" "$INV_FILE")"
      BASE_DIR="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.base_dir // empty" "$INV_FILE")"
      PORT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.port // empty" "$INV_FILE")"
      RUN_AS_USER="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.run_as_user // empty" "$INV_FILE")"
    elif jq -e ".hosts[\"$HOST\"].apps[\"$APP\"].service" "$INV_FILE" >/dev/null 2>&1; then
      HAS_SERVICE_OBJ="yes"
      SERVICE_UNIT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.service_unit // empty" "$INV_FILE")"
      BASE_DIR="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.base_dir // empty" "$INV_FILE")"
      PORT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.port // empty" "$INV_FILE")"
      RUN_AS_USER="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.run_as_user // empty" "$INV_FILE")"
      if jq -e ".hosts[\"$HOST\"].apps[\"$APP\"].components" "$INV_FILE" >/dev/null 2>&1; then
        HAS_COMPONENTS="yes"
      fi
    else
      # unknown schema, try generic fields
      SERVICE_UNIT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service_unit // empty" "$INV_FILE")"
      BASE_DIR="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].base_dir // empty" "$INV_FILE")"
      PORT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].port // empty" "$INV_FILE")"
      RUN_AS_USER="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].run_as_user // empty" "$INV_FILE")"
    fi

    [[ -n "$RUN_AS_USER" ]] || die "run_as_user is not defined for $HOST/$APP (required)."
  fi

  # ---- SSH target + per-host overrides (user/jump/port)
  # default target host (may be overridden by MW_SSH_TARGET env)
  local SSH_TARGET="${MW_SSH_TARGET:-$HOST}"

  # Read optional SSH overrides from inventory
  local SSH_USER SSH_JUMP SSH_PORT SSH_HOST_OVERRIDE
  SSH_USER="$(jq -r ".hosts[\"$HOST\"].ssh.user // empty" "$INV_FILE")"
  SSH_JUMP="$(jq -r ".hosts[\"$HOST\"].ssh.jump // empty" "$INV_FILE")"
  SSH_PORT="$(jq -r ".hosts[\"$HOST\"].ssh.port // empty" "$INV_FILE")"
  SSH_HOST_OVERRIDE="$(jq -r ".hosts[\"$HOST\"].ssh.host // empty" "$INV_FILE")"

  # If inventory specifies a different host for SSH, use it
  if [[ -n "$SSH_HOST_OVERRIDE" ]]; then
    SSH_TARGET="$SSH_HOST_OVERRIDE"
  fi

  # If a user is provided, prefix user@ to target (only if not set via MW_SSH_TARGET)
  if [[ -n "$SSH_USER" && -z "${MW_SSH_TARGET:-}" ]]; then
    SSH_TARGET="${SSH_USER}@${SSH_TARGET}"
  fi

  header() {
    echo "--------------------------------------------"
    echo "Client : $CLIENT_NAME"
    echo "Host   : $HOST"
    echo "Env    : $ENVIRONMENT"
    echo "App    : ${APP:-<ALL>}"
    if [[ -n "${SERVICE_UNIT:-}" ]]; then
      echo "Service: $SERVICE_UNIT"
      echo "RunAs  : $RUN_AS_USER"
    fi
    echo "--------------------------------------------"
    echo
  }

  run_ssh() {
    local cmd="$1"
    local wrapped="export SYSTEMD_PAGER=cat; export PAGER=cat; $cmd"

    # Build extra ssh args per-host
    local extra_opts=()
    if [[ -n "$SSH_JUMP" ]]; then
      extra_opts+=("-J" "$SSH_JUMP")
    fi
    if [[ -n "$SSH_PORT" && "$SSH_PORT" != "22" ]]; then
      extra_opts+=("-p" "$SSH_PORT")
    fi

    ssh "${SSH_OPTS[@]}" "${extra_opts[@]}" "$SSH_TARGET" "bash -lc $(printf '%q' "$wrapped")"
  }

  # Run any command as RUN_AS_USER
  as_runas_user() {
    local cmd="$1"
    echo "sudo -u $RUN_AS_USER bash -lc $(printf '%q' "$cmd")"
  }

  # Run systemctl as root but invoked by RUN_AS_USER
  sysctl() {
    local action="$1"
    local unit="$2"
    echo "$(as_runas_user "sudo -n /bin/systemctl $action $unit")"
  }

  exec_or_print() {
    local remote_cmd="$1"

    if [[ "$EXEC_MODE" == "print" ]]; then
      header
      echo "Run on server:"
      echo "  $remote_cmd"
      return 0
    fi

    header
    echo "Executing via SSH on: $SSH_TARGET"
    echo

    local out=""
    if ! out="$(run_ssh "$remote_cmd" 2>&1)"; then
      echo "$out"
      echo
      echo "Hint: This tool runs in non-interactive mode. Ensure sudoers allow required commands without password."
      return 1
    fi
    echo "$out"
  }

  # Helper: resolve component unit or logs
  resolve_component_unit() {
    local comp="$1"
    local unit
    unit="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$comp\"].service_unit // empty" "$INV_FILE")"
    echo "$unit"
  }
  resolve_component_log() {
    local comp="$1"; local logkey="$2"
    local lpath
    lpath="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$comp\"].logs[\"$logkey\"] // empty" "$INV_FILE")"
    echo "$lpath"
  }

  case "$CMD" in
    info)
      if [[ -n "$APP" ]]; then
        header
        echo "Base Dir : $BASE_DIR"
        echo "Port     : $PORT"
        echo "Run As   : $RUN_AS_USER"
        echo
        echo "Available logs:"
        if [[ "$HAS_TOMCAT" == "yes" ]]; then
          jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.logs | keys[]" "$INV_FILE" | sed 's/^/  - /'
        elif [[ "$HAS_COMPONENTS" == "yes" ]]; then
          jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components | keys[]" "$INV_FILE" | sed 's/^/  - /'
        else
          jq -r ".hosts[\"$HOST\"].apps[\"$APP\"] | keys[]" "$INV_FILE" | sed 's/^/  - /' || true
        fi
      else
        echo "--------------------------------------------"
        echo "Client : $CLIENT_NAME"
        echo "Host   : $HOST"
        echo "Env    : $ENVIRONMENT"
        echo "--------------------------------------------"
        echo

        mapfile -t all_apps < <(jq -r ".hosts[\"$HOST\"].apps | keys[]" "$INV_FILE")
        if [[ ${#all_apps[@]} -eq 0 ]]; then
          echo "No apps defined for this host."
          return 0
        fi

        for a in "${all_apps[@]}"; do
          local su bd pt ru url
          # Prefer tomcat schema if present
          if jq -e ".hosts[\"$HOST\"].apps[\"$a\"].tomcat" "$INV_FILE" >/dev/null 2>&1; then
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
            bd="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.base_dir // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"
            url="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.url // empty" "$INV_FILE")"
          else
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.service_unit // \"<missing>\"" "$INV_FILE")"
            bd="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.base_dir // \"<missing>\"" "$INV_FILE" 2>/dev/null || jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.base_dir // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.run_as_user // \"<missing>\"" "$INV_FILE")"
            url="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.url // empty" "$INV_FILE")"
          fi

          echo "APP: $a"
          echo "  Service : $su"
          echo "  Base Dir: $bd"
          echo "  Port    : $pt"
          echo "  Run As  : $ru"
          if [[ -n "$url" && "$url" != "null" ]]; then
            echo "  URL     : $url"
          fi

          echo "  Logs:"
          if jq -e ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.logs" "$INV_FILE" >/dev/null 2>&1; then
            jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.logs | to_entries[] | \"    - \(.key): \(.value)\"" "$INV_FILE"
          elif jq -e ".hosts[\"$HOST\"].apps[\"$a\"].components" "$INV_FILE" >/dev/null 2>&1; then
            jq -r ".hosts[\"$HOST\"].apps[\"$a\"].components | to_entries[] | \"    - \(.key) -> logs: \(.value.logs // {} | keys[])\" " "$INV_FILE" 2>/dev/null || echo "    - <component logs present>"
          else
            echo "    - <none>"
          fi
          echo
        done
      fi
      ;;

    status)
      if [[ -n "$APP" ]]; then
        # If component specified, prefer component unit
        if [[ -n "$COMPONENT_ARG" ]]; then
          # accept component key case-insensitive by trying raw then uppercased
          comp_unit="$(resolve_component_unit "$COMPONENT_ARG")"
          if [[ -z "$comp_unit" ]]; then
            comp_unit="$(resolve_component_unit "$(echo "$COMPONENT_ARG" | tr '[:lower:]' '[:upper:]')")"
          fi
          [[ -n "$comp_unit" ]] || die "Component '$COMPONENT_ARG' not found for $HOST/$APP."
          cmd_status="$(sysctl status "$comp_unit")"
          cmd_active="$(sysctl is-active "$comp_unit")"
          exec_or_print "$cmd_status; echo; $cmd_active"
          return 0
        fi

        # Show main service unit status
        local remote=""
        remote+="echo 'Client : $CLIENT_NAME';"
        remote+="echo 'Host   : $HOST';"
        remote+="echo 'Env    : $ENVIRONMENT';"
        remote+="echo 'App    : $APP';"
        remote+="echo;"

        if [[ -n "$SERVICE_UNIT" && "$SERVICE_UNIT" != "null" ]]; then
          remote+="$(sysctl "status" "$SERVICE_UNIT") | sed 's/^/Main: /';"
          remote+="echo; $(sysctl "is-active" "$SERVICE_UNIT") | sed 's/^/Main-State: /';"
        else
          remote+="echo 'Main: <no main unit defined>';"
        fi

        # If components exist, list each component's state
        if [[ "$HAS_COMPONENTS" == "yes" ]]; then
          # iterate components keys
          mapfile -t comp_keys < <(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components | keys[]" "$INV_FILE")
          for ck in "${comp_keys[@]}"; do
            unit="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$ck\"].service_unit // empty" "$INV_FILE")"
            if [[ -n "$unit" ]]; then
              remote+="echo 'Component: $ck';"
              remote+="$(sysctl "is-active" "$unit") | sed 's/^/  State: /';"
              remote+="echo '  Unit : $unit';"
              remote+="echo;"
            else
              remote+="echo 'Component: $ck (no unit defined)';"
              remote+="echo;"
            fi
          done
        else
          # Try to infer from services array if present
          if jq -e ".hosts[\"$HOST\"].apps[\"$APP\"].services" "$INV_FILE" >/dev/null 2>&1; then
            mapfile -t sarr < <(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].services[] | select(.!=null)" "$INV_FILE")
            for su in "${sarr[@]}"; do
              remote+="echo 'Service: $su';"
              remote+="$(sysctl "is-active" "$su") | sed 's/^/  State: /';"
              remote+="echo;"
            done
          fi
        fi

        exec_or_print "$remote"
        return 0
      fi

      # Multi-app status for this host (ALL apps) - unchanged logic
      as_user() {
        local ru="$1"; shift
        local cmd="$*"
        echo "sudo -u $ru bash -lc $(printf '%q' "$cmd")"
      }
      sysctl_user() {
        local ru="$1"; local action="$2"; local unit="$3"
        echo "$(as_user "$ru" "sudo -n /bin/systemctl $action $unit")"
      }

      mapfile -t all_apps < <(jq -r ".hosts[\"$HOST\"].apps | keys[]" "$INV_FILE")
      header
      echo "App    : <ALL>"
      echo

      if [[ ${#all_apps[@]} -eq 0 ]]; then
        echo "No apps defined for this host."
        return 0
      fi

      if [[ "$EXEC_MODE" == "exec" ]]; then
        local remote=""
        remote+="echo 'Client : $CLIENT_NAME';"
        remote+="echo 'Host   : $HOST';"
        remote+="echo 'Env    : $ENVIRONMENT';"
        remote+="echo 'App    : <ALL>';"
        remote+="echo;"

        for a in "${all_apps[@]}"; do
          local su pt ru
          if jq -e ".hosts[\"$HOST\"].apps[\"$a\"].tomcat" "$INV_FILE" >/dev/null 2>&1; then
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"
          else
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.service_unit // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.run_as_user // \"<missing>\"" "$INV_FILE")"
          fi

          remote+="echo 'APP: $a';"
          remote+="echo '  Service : $su';"
          remote+="echo '  Port    : $pt';"
          remote+="echo '  Run As  : $ru';"

          if [[ "$ru" != "<missing>" && "$su" != "<missing>" ]]; then
            remote+="$(sysctl_user "$ru" "is-active" "$su") | sed 's/^/  State   : /';"
          else
            remote+="echo '  State   : unknown';"
          fi

          if [[ "$ru" != "<missing>" && "$pt" != "<missing>" ]]; then
            remote+="$(as_user "$ru" "ss -lnt 2>/dev/null | grep -E '[:.]$pt\\b' >/dev/null && echo listening || echo not_listening") | sed 's/^/  Listen  : /';"
          else
            remote+="echo '  Listen  : unknown';"
          fi

          remote+="echo;"
        done

        exec_or_print "$remote"
      else
        # Print-mode: no real state
        for a in "${all_apps[@]}"; do
          local su pt ru
          if jq -e ".hosts[\"$HOST\"].apps[\"$a\"].tomcat" "$INV_FILE" >/dev/null 2>&1; then
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"
          else
            su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.service_unit // \"<missing>\"" "$INV_FILE")"
            pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.port // \"<missing>\"" "$INV_FILE")"
            ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].service.run_as_user // \"<missing>\"" "$INV_FILE")"
          fi

          echo "APP: $a"
          echo "  Service : $su"
          echo "  Port    : $pt"
          echo "  Run As  : $ru"
          echo "  State   : (run with --exec)"
          echo "  Listen  : (run with --exec)"
          echo
        done
      fi
      ;;

    logs)
      [[ -n "$APP" ]] || die "logs requires <APP>. Example: appctl logs PRCC TEST BEP catalina"
      [[ ${#OTHER_ARGS[@]} -ge 1 ]] || die "Missing <logname> for 'logs' command."
      local LOGNAME="${OTHER_ARGS[0]}"

      local LINES=200
      local FILTER=""
      local idx=1

      # Robust flag parsing: supports --lines N and --filter REGEX in any order
      while [[ $idx -lt ${#OTHER_ARGS[@]} ]]; do
        case "${OTHER_ARGS[$idx]}" in
          --lines)
            ((idx++))
            [[ $idx -lt ${#OTHER_ARGS[@]} ]] || die "--lines requires a number"
            [[ "${OTHER_ARGS[$idx]}" =~ ^[0-9]+$ ]] || die "--lines must be a number. Got: '${OTHER_ARGS[$idx]}'"
            LINES="${OTHER_ARGS[$idx]}"
            ;;
          --filter)
            ((idx++))
            [[ $idx -lt ${#OTHER_ARGS[@]} ]] || die "--filter requires a value"
            FILTER="${OTHER_ARGS[$idx]}"
            ;;
          *)
            ;;
        esac
        ((idx++))
      done

      local LOGPATH=""
      if [[ -n "$COMPONENT_ARG" ]]; then
        LOGPATH="$(resolve_component_log "$COMPONENT_ARG" "$LOGNAME")"
        if [[ -z "$LOGPATH" ]]; then
          die "Log '$LOGNAME' not found under component '$COMPONENT_ARG' for $HOST/$APP."
        fi
      else
        # try tomcat logs first, then service-level logs
        LOGPATH="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.logs[\"$LOGNAME\"] // empty" "$INV_FILE")"
        if [[ -z "$LOGPATH" ]]; then
          LOGPATH="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.logs[\"$LOGNAME\"] // empty" "$INV_FILE")"
        fi
      fi

      # FUZZY fallback: if not found in tomcat/service and no component specified,
      # search components.*.logs keys case-insensitive and by substring match
      if [[ -z "$LOGPATH" && -z "$COMPONENT_ARG" ]]; then
        candidate=""
        found_comp=""
        found_key=""
        query="$(echo "$LOGNAME" | tr '[:upper:]' '[:lower:]')"

        # iterate components
        while IFS= read -r comp; do
          # iterate keys in this component.logs
          jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$comp\"].logs // {} | keys[]" "$INV_FILE" 2>/dev/null \
          | while IFS= read -r k; do
            kl="$(echo "$k" | tr '[:upper:]' '[:lower:]')"
            if [[ "$kl" == "$query" || "$kl" == *"$query"* || "$query" == *"$kl"* ]]; then
              cand="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$comp\"].logs[\"$k\"] // empty" "$INV_FILE")"
              if [[ -n "$cand" ]]; then
                candidate="$cand"
                found_comp="$comp"
                found_key="$k"
                break 2
              fi
            fi
          done
        done < <(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components | keys[]" "$INV_FILE" 2>/dev/null)

        if [[ -n "$candidate" ]]; then
          LOGPATH="$candidate"
          echo "Note: fuzzy-resolved log '$LOGNAME' -> component '$found_comp' key '$found_key' path: $LOGPATH" >&2
        fi
      fi

      [[ -n "$LOGPATH" ]] || die "Log '$LOGNAME' not found for $HOST/$APP."

      # Build safe command
      local q_path q_filter cmd
      q_path="$(printf '%q' "$LOGPATH")"

      cmd="tail -n $LINES $q_path"
      if [[ -n "$FILTER" ]]; then
        q_filter="$(printf '%q' "$FILTER")"
        cmd="$cmd | grep -Ei -- $q_filter || true"
      fi

      exec_or_print "$(as_runas_user "$cmd")"
      ;;

    journal)
      [[ -n "$APP" ]] || die "journal requires <APP>. Example: appctl journal PRCC TEST BEP"
      local LINES=200
      local j=0
      while [[ $j -lt ${#OTHER_ARGS[@]} ]]; do
        if [[ "${OTHER_ARGS[$j]}" == "--lines" ]]; then
          LINES="${OTHER_ARGS[$((j+1))]:-200}"
        fi
        j=$((j+1))
      done
      [[ "$LINES" =~ ^[0-9]+$ ]] || die "--lines must be a number. Got: '$LINES'"

      # If component specified, prefer its unit
      if [[ -n "$COMPONENT_ARG" ]]; then
        comp_unit="$(resolve_component_unit "$COMPONENT_ARG")"
        [[ -n "$comp_unit" ]] || die "Component '$COMPONENT_ARG' not found for $HOST/$APP."
        exec_or_print "$(as_runas_user "journalctl -u $comp_unit -n $LINES --no-pager")"
      else
        exec_or_print "$(as_runas_user "journalctl -u $SERVICE_UNIT -n $LINES --no-pager")"
      fi
      ;;

    url)
      [[ -n "$APP" ]] || die "url requires <APP>. Example: appctl url PRCC TEST BEP"

      local URL=""

      # 1) If component specified, prefer component url
      if [[ -n "$COMPONENT_ARG" ]]; then
        URL="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$COMPONENT_ARG\"].url // empty" "$INV_FILE" 2>/dev/null)"
        if [[ -z "$URL" ]]; then
          # try uppercase variant
          URL="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].components[\"$(echo "$COMPONENT_ARG" | tr '[:lower:]' '[:upper:]')\"].url // empty" "$INV_FILE" 2>/dev/null)"
        fi
        [[ -n "$URL" && "$URL" != "null" ]] || die "No URL defined for component '$COMPONENT_ARG' on $HOST/$APP."
      else
        # 2) Default app URL (service.url), then tomcat.url
        URL="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].service.url // empty" "$INV_FILE")"
        if [[ -z "$URL" || "$URL" == "null" ]]; then
          URL="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.url // empty" "$INV_FILE")"
        fi
      fi

      if [[ -z "$URL" || "$URL" == "null" ]]; then
        header
        echo "No URL defined for this app."
        return 0
      fi

      local remote_cmd
      remote_cmd="$(as_runas_user "curl -s -o /dev/null -w \"%{http_code} %{time_total}\" -m 10 \"$URL\"")"

      if [[ "$EXEC_MODE" == "print" ]]; then
        header
        echo "URL:"
        echo "  $URL"
        echo
        echo "Test from server:"
        echo "  $remote_cmd"
        return 0
      fi

      header
      echo "Executing via SSH on: $SSH_TARGET"
      echo

      local out=""
      if ! out="$(run_ssh "$remote_cmd" 2>&1)"; then
        echo "URL     : $URL"
        echo "HTTP    : ERROR"
        echo "Time    : -"
        echo "Error   : $out"
        return 1
      fi

      local HTTP_CODE TIME_TOTAL
      HTTP_CODE="$(echo "$out" | awk '{print $1}')"
      TIME_TOTAL="$(echo "$out" | awk '{print $2}')"

      echo "URL     : $URL"
      echo "HTTP    : $HTTP_CODE"
      echo "Time    : ${TIME_TOTAL}s"
      ;;


    start)
      [[ -n "$APP" ]] || die "start requires <APP>. Example: appctl start PRCC TEST BEP --exec"
      if [[ -n "$COMPONENT_ARG" ]]; then
        comp_unit="$(resolve_component_unit "$COMPONENT_ARG")"
        [[ -n "$comp_unit" ]] || die "Component '$COMPONENT_ARG' not found for $HOST/$APP."
        cmd_start="$(sysctl start "$comp_unit")"
        cmd_verify="$(sysctl is-active "$comp_unit")"
        exec_or_print "$cmd_start; echo; echo Verifying...; $cmd_verify"
      else
        cmd_start="$(sysctl start "$SERVICE_UNIT")"
        cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
        cmd_ports="$(as_runas_user "ss -lntp 2>/dev/null | grep -E '[:.]$PORT\\b' || true")"
        exec_or_print "$cmd_start; echo; echo Verifying...; $cmd_verify; echo; $cmd_ports"
      fi
      ;;

    stop)
      [[ -n "$APP" ]] || die "stop requires <APP>. Example: appctl stop PRCC TEST BEP --exec"
      if [[ -n "$COMPONENT_ARG" ]]; then
        comp_unit="$(resolve_component_unit "$COMPONENT_ARG")"
        [[ -n "$comp_unit" ]] || die "Component '$COMPONENT_ARG' not found for $HOST/$APP."
        cmd_stop="$(sysctl stop "$comp_unit")"
        cmd_verify="$(sysctl is-active "$comp_unit")"
        exec_or_print "$cmd_stop; echo; echo Verifying...; $cmd_verify"
      else
        cmd_stop="$(sysctl stop "$SERVICE_UNIT")"
        cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
        exec_or_print "$cmd_stop; echo; echo Verifying...; $cmd_verify"
      fi
      ;;

    restart)
      [[ -n "$APP" ]] || die "restart requires <APP>. Example: appctl restart PRCC TEST BEP --exec"
      if [[ -n "$COMPONENT_ARG" ]]; then
        comp_unit="$(resolve_component_unit "$COMPONENT_ARG")"
        [[ -n "$comp_unit" ]] || die "Component '$COMPONENT_ARG' not found for $HOST/$APP."
        cmd_restart="$(sysctl restart "$comp_unit")"
        cmd_verify="$(sysctl is-active "$comp_unit")"
        exec_or_print "$cmd_restart; echo; echo Verifying...; $cmd_verify"
      else
        cmd_restart="$(sysctl restart "$SERVICE_UNIT")"
        cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
        cmd_ports="$(as_runas_user "ss -lntp 2>/dev/null | grep -E '[:.]$PORT\\b' || true")"
        exec_or_print "$cmd_restart; echo; echo Verifying...; $cmd_verify; echo; $cmd_ports"
      fi
      ;;

    *)
      usage
      die "Unknown command: $CMD"
      ;;
  esac
}

if [[ ${#TARGET_HOSTS[@]} -eq 1 ]]; then
  run_for_host "${TARGET_HOSTS[0]}"
else
  for h in "${TARGET_HOSTS[@]}"; do
    echo
    echo "=============================="
    echo " Running on host: $h"
    echo "=============================="
    run_for_host "$h"
  done
fi
