#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
INV_DIR="$ROOT_DIR/inventory"

die() { echo "ERROR: $*" >&2; exit 1; }

usage() {
cat <<'EOF'
Usage:
  appctl <cmd> <CLIENT> <HOST|ENV> <APP> [args...] [--all] [--exec]
  appctl info   <CLIENT> <HOST|ENV> [APP] [--all] [--exec]
  appctl status <CLIENT> <HOST|ENV> [APP] [--all] [--exec]

Commands:
  info
  status
  logs <logname> [--lines N] [--filter REGEX]
  journal [--lines N]
  url
  start
  stop
  restart

Modes:
  (default) print commands only (no SSH)
  --exec    run via SSH (non-interactive only). No password prompts expected.

Environment targeting:
  - The 3rd arg may be a host (e.g. it-s-banethos-t) OR an environment (e.g. TEST).
  - If ENV matches one host: it will be used automatically.
  - If ENV matches multiple hosts:
      - default behavior: appctl prints candidates and exits unless you add --all.
      - EXCEPTION: `status` without APP defaults to all hosts in the environment.

Execution model:
  - All remote commands run as the inventory run_as_user (e.g., tomcat) via:
      sudo -u <run_as_user> bash -lc '<cmd>'
  - systemctl is executed as root but invoked by run_as_user:
      sudo -n /bin/systemctl <action> <unit>

Examples:
  appctl info PRCC TEST BEP
  appctl info PRCC TEST
  appctl info PRCC it-s-banethos-t

  appctl status PRCC TEST --exec
  appctl status PRCC it-s-banethos-t --exec
  appctl status PRCC it-s-banethos-t BEP --exec

  appctl logs PRCC TEST BEP catalina --lines 50 --filter ERROR --exec
  appctl restart PRCC TEST BEP --exec
EOF
}

# ---- Parse leading args ----
[[ $# -ge 1 ]] || { usage; exit 1; }
CMD="$1"; shift || true

# Require at least CLIENT + HOST|ENV for info/status; for others require +APP
[[ $# -ge 2 ]] || { usage; exit 1; }
CLIENT_RAW="$1"; shift
IDENT="$1"; shift   # HOST or ENV

APP=""
if [[ "$CMD" == "info" || "$CMD" == "status" ]]; then
  # info/status allow optional APP (if next token is not an option)
  if [[ $# -ge 1 && "${1:0:2}" != "--" ]]; then
    APP="$1"; shift
  fi
else
  [[ $# -ge 1 ]] || { usage; die "Missing <APP> for command '$CMD'"; }
  APP="$1"; shift
fi

CLIENT="$(echo "$CLIENT_RAW" | tr '[:upper:]' '[:lower:]')"
INV_FILE="$INV_DIR/${CLIENT}.json"
[[ -f "$INV_FILE" ]] || die "Inventory not found: $INV_FILE"

command -v jq >/dev/null 2>&1 || die "jq is required but not found in PATH."

# ---- Parse options anywhere in remaining args ----
ALL_MODE="no"
EXEC_MODE="print"   # print | exec
OTHER_ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --all) ALL_MODE="yes"; shift ;;
    --exec) EXEC_MODE="exec"; shift ;;
    --exec-tty) die "--exec-tty is not supported anymore. Use --exec." ;;
    -h|--help|help) usage; exit 0 ;;
    *) OTHER_ARGS+=("$1"); shift ;;
  esac
done

# ---- Resolve IDENT => host(s) ----
hosts_for_env() {
  local wanted="$1"
  local wanted_lc
  wanted_lc="$(echo "$wanted" | tr '[:upper:]' '[:lower:]' | sed 's/[[:space:]]\+$//')"

  jq -r '.hosts | to_entries[] | "\(.key)\t\(.value.environment // "")"' "$INV_FILE" \
  | while IFS=$'\t' read -r host env; do
      env="$(echo "$env" | sed 's/^[[:space:]]\+//; s/[[:space:]]\+$//')"
      env_lc="$(echo "$env" | tr '[:upper:]' '[:lower:]')"
      if [[ "$env_lc" == "$wanted_lc" ]]; then
        echo "$host"
      fi
    done
}

IDENT_IS_HOST="no"
TARGET_HOSTS=()

IDENT_LC="$(echo "$IDENT" | tr '[:upper:]' '[:lower:]')"
if jq -e ".hosts[\"$IDENT\"]" "$INV_FILE" >/dev/null 2>&1; then
  IDENT_IS_HOST="yes"
  TARGET_HOSTS=("$IDENT")
elif jq -e ".hosts[\"$IDENT_LC\"]" "$INV_FILE" >/dev/null 2>&1; then
  IDENT_IS_HOST="yes"
  TARGET_HOSTS=("$IDENT_LC")
else
  mapfile -t env_hosts < <(hosts_for_env "$IDENT")
  [[ ${#env_hosts[@]} -gt 0 ]] || die "Neither host '$IDENT' exists nor environment '$IDENT' matches any host in this inventory."
  TARGET_HOSTS=("${env_hosts[@]}")
fi

# If status without APP and ENV matches multiple hosts => default to all hosts (no prompt)
if [[ "$CMD" == "status" && -z "$APP" && "$IDENT_IS_HOST" != "yes" && ${#TARGET_HOSTS[@]} -gt 1 ]]; then
  ALL_MODE="yes"
fi

if [[ "$IDENT_IS_HOST" != "yes" && ${#TARGET_HOSTS[@]} -gt 1 && "$ALL_MODE" != "yes" ]]; then
  echo "The identifier '$IDENT' matches multiple hosts for client '$CLIENT_RAW':"
  for h in "${TARGET_HOSTS[@]}"; do
    env_val="$(jq -r ".hosts[\"$h\"].environment // \"<missing>\"" "$INV_FILE")"
    desc="$(jq -r ".hosts[\"$h\"].description // \"<no description>\"" "$INV_FILE")"
    echo "  - $h (env: $env_val) - $desc"
  done
  echo
  echo "Run again with a specific host, e.g.:"
  if [[ -n "$APP" ]]; then
    echo "  appctl $CMD $CLIENT_RAW ${TARGET_HOSTS[0]} $APP ${OTHER_ARGS[*]}"
  else
    echo "  appctl $CMD $CLIENT_RAW ${TARGET_HOSTS[0]} ${OTHER_ARGS[*]}"
  fi
  echo
  echo "Or run against all hosts in the environment with --all, e.g.:"
  if [[ -n "$APP" ]]; then
    echo "  appctl $CMD $CLIENT_RAW $IDENT $APP ${OTHER_ARGS[*]} --all --exec"
  else
    echo "  appctl $CMD $CLIENT_RAW $IDENT ${OTHER_ARGS[*]} --all --exec"
  fi
  exit 0
fi

# ---- SSH helpers ----
SSH_OPTS=(
  -o BatchMode=yes
  -o ConnectTimeout=10
  -o StrictHostKeyChecking=accept-new
  -o ServerAliveInterval=15
  -o ServerAliveCountMax=2
  -o LogLevel=ERROR
)

run_for_host() {
  local HOST="$1"

  jq -e ".hosts[\"$HOST\"]" "$INV_FILE" >/dev/null || die "Host '$HOST' not found in inventory."

  # If APP is provided, ensure it exists.
  if [[ -n "$APP" ]]; then
    jq -e ".hosts[\"$HOST\"].apps[\"$APP\"]" "$INV_FILE" >/dev/null || die "App '$APP' not found on host '$HOST'."
  fi

  local CLIENT_NAME ENVIRONMENT
  CLIENT_NAME="$(jq -r ".client_name" "$INV_FILE")"
  ENVIRONMENT="$(jq -r ".hosts[\"$HOST\"].environment" "$INV_FILE")"

  # App-scoped values (only when APP is set)
  local SERVICE_UNIT BASE_DIR PORT RUN_AS_USER
  if [[ -n "$APP" ]]; then
    SERVICE_UNIT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.service_unit" "$INV_FILE")"
    BASE_DIR="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.base_dir" "$INV_FILE")"
    PORT="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.port" "$INV_FILE")"
    RUN_AS_USER="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.run_as_user // empty" "$INV_FILE")"
    [[ -n "$RUN_AS_USER" ]] || die "run_as_user is not defined for $HOST/$APP (required)."
  fi

  local SSH_TARGET="${MW_SSH_TARGET:-$HOST}"

  header() {
    echo "--------------------------------------------"
    echo "Client : $CLIENT_NAME"
    echo "Host   : $HOST"
    echo "Env    : $ENVIRONMENT"
    echo "App    : ${APP:-<ALL>}"
    if [[ -n "${SERVICE_UNIT:-}" ]]; then
      echo "Service: $SERVICE_UNIT"
      echo "RunAs  : $RUN_AS_USER"
    fi
    echo "--------------------------------------------"
    echo
  }

  run_ssh() {
    local cmd="$1"
    local wrapped="export SYSTEMD_PAGER=cat; export PAGER=cat; $cmd"
    ssh "${SSH_OPTS[@]}" "$SSH_TARGET" "bash -lc $(printf '%q' "$wrapped")"
  }

  # Run any command as RUN_AS_USER
  as_runas_user() {
    local cmd="$1"
    echo "sudo -u $RUN_AS_USER bash -lc $(printf '%q' "$cmd")"
  }

  # Run systemctl as root but invoked by RUN_AS_USER
  sysctl() {
    local action="$1"
    local unit="$2"
    echo "$(as_runas_user "sudo -n /bin/systemctl $action $unit")"
  }

  exec_or_print() {
    local remote_cmd="$1"

    if [[ "$EXEC_MODE" == "print" ]]; then
      header
      echo "Run on server:"
      echo "  $remote_cmd"
      return 0
    fi

    header
    echo "Executing via SSH on: $SSH_TARGET"
    echo

    local out=""
    if ! out="$(run_ssh "$remote_cmd" 2>&1)"; then
      echo "$out"
      echo
      echo "Hint: This tool runs in non-interactive mode. Ensure sudoers allow required commands without password."
      return 1
    fi
    echo "$out"
  }

  case "$CMD" in
    info)
      if [[ -n "$APP" ]]; then
        header
        echo "Base Dir : $BASE_DIR"
        echo "Port     : $PORT"
        echo "Run As   : $RUN_AS_USER"
        echo
        echo "Available logs:"
        jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.logs | keys[]" "$INV_FILE" | sed 's/^/  - /'
      else
        echo "--------------------------------------------"
        echo "Client : $CLIENT_NAME"
        echo "Host   : $HOST"
        echo "Env    : $ENVIRONMENT"
        echo "--------------------------------------------"
        echo

        mapfile -t all_apps < <(jq -r ".hosts[\"$HOST\"].apps | keys[]" "$INV_FILE")
        if [[ ${#all_apps[@]} -eq 0 ]]; then
          echo "No apps defined for this host."
          return 0
        fi

        for a in "${all_apps[@]}"; do
          local su bd pt ru url
          su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
          bd="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.base_dir // \"<missing>\"" "$INV_FILE")"
          pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
          ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"
          url="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.url // empty" "$INV_FILE")"

          echo "APP: $a"
          echo "  Service : $su"
          echo "  Base Dir: $bd"
          echo "  Port    : $pt"
          echo "  Run As  : $ru"
          if [[ -n "$url" && "$url" != "null" ]]; then
            echo "  URL     : $url"
          fi

          echo "  Logs:"
          if jq -e ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.logs" "$INV_FILE" >/dev/null 2>&1; then
            jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.logs | to_entries[] | \"    - \(.key): \(.value)\"" "$INV_FILE"
          else
            echo "    - <none>"
          fi
          echo
        done
      fi
      ;;

    status)
      if [[ -n "$APP" ]]; then
        local cmd_status cmd_active cmd_ports
        cmd_status="$(sysctl status "$SERVICE_UNIT")"
        cmd_active="$(sysctl is-active "$SERVICE_UNIT")"
        cmd_ports="$(as_runas_user "ss -lntp 2>/dev/null | grep -E '[:.]$PORT\\b' || true")"
        exec_or_print "$cmd_status; echo; $cmd_active; echo; $cmd_ports"
        return 0
      fi

      # Multi-app status for this host (ALL apps)
      as_user() {
        local ru="$1"; shift
        local cmd="$*"
        echo "sudo -u $ru bash -lc $(printf '%q' "$cmd")"
      }
      sysctl_user() {
        local ru="$1"; local action="$2"; local unit="$3"
        echo "$(as_user "$ru" "sudo -n /bin/systemctl $action $unit")"
      }

      mapfile -t all_apps < <(jq -r ".hosts[\"$HOST\"].apps | keys[]" "$INV_FILE")
      header
      echo "App    : <ALL>"
      echo

      if [[ ${#all_apps[@]} -eq 0 ]]; then
        echo "No apps defined for this host."
        return 0
      fi

      if [[ "$EXEC_MODE" == "exec" ]]; then
        local remote=""
        remote+="echo 'Client : $CLIENT_NAME';"
        remote+="echo 'Host   : $HOST';"
        remote+="echo 'Env    : $ENVIRONMENT';"
        remote+="echo 'App    : <ALL>';"
        remote+="echo;"

        for a in "${all_apps[@]}"; do
          local su pt ru
          su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
          pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
          ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"

          remote+="echo 'APP: $a';"
          remote+="echo '  Service : $su';"
          remote+="echo '  Port    : $pt';"
          remote+="echo '  Run As  : $ru';"

          if [[ "$ru" != "<missing>" && "$su" != "<missing>" ]]; then
            remote+="$(sysctl_user "$ru" "is-active" "$su") | sed 's/^/  State   : /';"
          else
            remote+="echo '  State   : unknown';"
          fi

          if [[ "$ru" != "<missing>" && "$pt" != "<missing>" ]]; then
            remote+="$(as_user "$ru" "ss -lnt 2>/dev/null | grep -E '[:.]$pt\\b' >/dev/null && echo listening || echo not_listening") | sed 's/^/  Listen  : /';"
          else
            remote+="echo '  Listen  : unknown';"
          fi

          remote+="echo;"
        done

        exec_or_print "$remote"
      else
        # Print-mode: no real state
        for a in "${all_apps[@]}"; do
          local su pt ru
          su="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.service_unit // \"<missing>\"" "$INV_FILE")"
          pt="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.port // \"<missing>\"" "$INV_FILE")"
          ru="$(jq -r ".hosts[\"$HOST\"].apps[\"$a\"].tomcat.run_as_user // \"<missing>\"" "$INV_FILE")"

          echo "APP: $a"
          echo "  Service : $su"
          echo "  Port    : $pt"
          echo "  Run As  : $ru"
          echo "  State   : (run with --exec)"
          echo "  Listen  : (run with --exec)"
          echo
        done
      fi
      ;;

    logs)
      [[ -n "$APP" ]] || die "logs requires <APP>. Example: appctl logs PRCC TEST BEP catalina"
      [[ ${#OTHER_ARGS[@]} -ge 1 ]] || die "Missing <logname> for 'logs' command."
      local LOGNAME="${OTHER_ARGS[0]}"

      local LINES=200
      local FILTER=""
      local idx=1

      # Robust flag parsing: supports --lines N and --filter REGEX in any order
      while [[ $idx -lt ${#OTHER_ARGS[@]} ]]; do
        case "${OTHER_ARGS[$idx]}" in
          --lines)
            ((idx++))
            [[ $idx -lt ${#OTHER_ARGS[@]} ]] || die "--lines requires a number"
            [[ "${OTHER_ARGS[$idx]}" =~ ^[0-9]+$ ]] || die "--lines must be a number. Got: '${OTHER_ARGS[$idx]}'"
            LINES="${OTHER_ARGS[$idx]}"
            ;;
          --filter)
            ((idx++))
            [[ $idx -lt ${#OTHER_ARGS[@]} ]] || die "--filter requires a value"
            FILTER="${OTHER_ARGS[$idx]}"
            ;;
          *)
            ;;
        esac
        ((idx++))
      done

      local LOGPATH
      LOGPATH="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.logs[\"$LOGNAME\"] // empty" "$INV_FILE")"
      [[ -n "$LOGPATH" ]] || die "Log '$LOGNAME' not found for $HOST/$APP."

      # Build safe command
      local q_path q_filter cmd
      q_path="$(printf '%q' "$LOGPATH")"

      cmd="tail -n $LINES $q_path"
      if [[ -n "$FILTER" ]]; then
        q_filter="$(printf '%q' "$FILTER")"
        cmd="$cmd | grep -Ei -- $q_filter || true"
      fi

      exec_or_print "$(as_runas_user "$cmd")"
      ;;

    journal)
      [[ -n "$APP" ]] || die "journal requires <APP>. Example: appctl journal PRCC TEST BEP"
      local LINES=200
      local j=0
      while [[ $j -lt ${#OTHER_ARGS[@]} ]]; do
        if [[ "${OTHER_ARGS[$j]}" == "--lines" ]]; then
          LINES="${OTHER_ARGS[$((j+1))]:-200}"
        fi
        j=$((j+1))
      done
      [[ "$LINES" =~ ^[0-9]+$ ]] || die "--lines must be a number. Got: '$LINES'"
      exec_or_print "$(as_runas_user "journalctl -u $SERVICE_UNIT -n $LINES --no-pager")"
      ;;

    url)
      [[ -n "$APP" ]] || die "url requires <APP>. Example: appctl url PRCC TEST BEP"
      local URL
      URL="$(jq -r ".hosts[\"$HOST\"].apps[\"$APP\"].tomcat.url // empty" "$INV_FILE")"
      if [[ -z "$URL" || "$URL" == "null" ]]; then
        header
        echo "No URL defined for this app."
        return 0
      fi

      local remote_cmd
      remote_cmd="$(as_runas_user "curl -s -o /dev/null -w \"%{http_code} %{time_total}\" -m 10 \"$URL\"")"

      if [[ "$EXEC_MODE" == "print" ]]; then
        header
        echo "URL:"
        echo "  $URL"
        echo
        echo "Test from server:"
        echo "  $remote_cmd"
        return 0
      fi

      header
      echo "Executing via SSH on: $SSH_TARGET"
      echo

      local out=""
      if ! out="$(run_ssh "$remote_cmd" 2>&1)"; then
        echo "URL     : $URL"
        echo "HTTP    : ERROR"
        echo "Time    : -"
        echo "Error   : $out"
        return 1
      fi

      local HTTP_CODE TIME_TOTAL
      HTTP_CODE="$(echo "$out" | awk '{print $1}')"
      TIME_TOTAL="$(echo "$out" | awk '{print $2}')"

      # Parse-friendly output for Slack dashboard
      echo "URL     : $URL"
      echo "HTTP    : $HTTP_CODE"
      echo "Time    : ${TIME_TOTAL}s"
      ;;

    start)
      [[ -n "$APP" ]] || die "start requires <APP>. Example: appctl start PRCC TEST BEP --exec"
      local cmd_start cmd_verify cmd_ports
      cmd_start="$(sysctl start "$SERVICE_UNIT")"
      cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
      cmd_ports="$(as_runas_user "ss -lntp 2>/dev/null | grep -E '[:.]$PORT\\b' || true")"
      exec_or_print "$cmd_start; echo; echo Verifying...; $cmd_verify; echo; $cmd_ports"
      ;;

    stop)
      [[ -n "$APP" ]] || die "stop requires <APP>. Example: appctl stop PRCC TEST BEP --exec"
      local cmd_stop cmd_verify
      cmd_stop="$(sysctl stop "$SERVICE_UNIT")"
      cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
      exec_or_print "$cmd_stop; echo; echo Verifying...; $cmd_verify"
      ;;

    restart)
      [[ -n "$APP" ]] || die "restart requires <APP>. Example: appctl restart PRCC TEST BEP --exec"
      local cmd_restart cmd_verify cmd_ports
      cmd_restart="$(sysctl restart "$SERVICE_UNIT")"
      cmd_verify="$(sysctl is-active "$SERVICE_UNIT")"
      cmd_ports="$(as_runas_user "ss -lntp 2>/dev/null | grep -E '[:.]$PORT\\b' || true")"
      exec_or_print "$cmd_restart; echo; echo Verifying...; $cmd_verify; echo; $cmd_ports"
      ;;

    *)
      usage
      die "Unknown command: $CMD"
      ;;
  esac
}

if [[ ${#TARGET_HOSTS[@]} -eq 1 ]]; then
  run_for_host "${TARGET_HOSTS[0]}"
else
  for h in "${TARGET_HOSTS[@]}"; do
    echo
    echo "=============================="
    echo " Running on host: $h"
    echo "=============================="
    run_for_host "$h"
  done
fi
